<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript[max] | KivenBlog</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/kiven.ico">
    <link rel="manifest" href="/manifest.json">
    <meta name="description" content="Record learning hobbies">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="theme-color" content="#b532b6">
    <link rel="preload" href="/assets/css/0.styles.dc74f534.css" as="style"><link rel="preload" href="/assets/js/app.471be3c8.js" as="script"><link rel="preload" href="/assets/js/3.ee027652.js" as="script"><link rel="preload" href="/assets/js/1.58bb6475.js" as="script"><link rel="preload" href="/assets/js/25.8741c09a.js" as="script"><link rel="preload" href="/assets/js/8.7e2c6b0f.js" as="script"><link rel="prefetch" href="/assets/js/10.b80417c3.js"><link rel="prefetch" href="/assets/js/11.0fc38194.js"><link rel="prefetch" href="/assets/js/12.23f96061.js"><link rel="prefetch" href="/assets/js/13.897dadfb.js"><link rel="prefetch" href="/assets/js/14.8028d46b.js"><link rel="prefetch" href="/assets/js/15.a0a88ed4.js"><link rel="prefetch" href="/assets/js/16.e7c88323.js"><link rel="prefetch" href="/assets/js/17.0ac6bbf4.js"><link rel="prefetch" href="/assets/js/18.22e17173.js"><link rel="prefetch" href="/assets/js/19.fb686249.js"><link rel="prefetch" href="/assets/js/20.c4df8ba1.js"><link rel="prefetch" href="/assets/js/21.27ff48a4.js"><link rel="prefetch" href="/assets/js/22.ce7a6b4f.js"><link rel="prefetch" href="/assets/js/23.c9c14921.js"><link rel="prefetch" href="/assets/js/24.f5c3a5bb.js"><link rel="prefetch" href="/assets/js/26.24348f78.js"><link rel="prefetch" href="/assets/js/27.37c8384f.js"><link rel="prefetch" href="/assets/js/4.deeb2ccd.js"><link rel="prefetch" href="/assets/js/5.2e4ee3bc.js"><link rel="prefetch" href="/assets/js/6.1b717280.js"><link rel="prefetch" href="/assets/js/7.6cfb4029.js"><link rel="prefetch" href="/assets/js/9.74d3dd21.js">
    <link rel="stylesheet" href="/assets/css/0.styles.dc74f534.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-2d5f533b><div data-v-2d5f533b><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-2d5f533b data-v-2d5f533b><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-2d5f533b data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>KivenBlog</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>KivenXue</span>
            
          <!---->
          2020
        </a></span></div></div> <div class="hide" data-v-2d5f533b><header class="navbar" data-v-2d5f533b><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="KivenBlog" class="logo"> <span class="site-name">KivenBlog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Bugfix/" class="nav-link"><i class="iconfont undefined"></i>
  Bugfix
</a></li><li class="dropdown-item"><!----> <a href="/categories/博文/" class="nav-link"><i class="iconfont undefined"></i>
  博文
</a></li><li class="dropdown-item"><!----> <a href="/categories/Life perception/" class="nav-link"><i class="iconfont undefined"></i>
  Life perception
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/notes/" class="nav-link router-link-active"><i class="iconfont reco-document"></i>
  Notes
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/Interview/" class="nav-link"><i class="iconfont reco-blog"></i>
  Interview
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-account"></i>
      About
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/recoluan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-2d5f533b></div> <aside class="sidebar" data-v-2d5f533b><div class="personal-info-wrapper" data-v-ca798c94 data-v-2d5f533b><img src="/avatar.jpg" alt="author-avatar" class="personal-img" data-v-ca798c94> <h3 class="name" data-v-ca798c94>
    KivenXue
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>5</h3> <h6 data-v-ca798c94>Article</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>6</h3> <h6 data-v-ca798c94>Tag</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Bugfix/" class="nav-link"><i class="iconfont undefined"></i>
  Bugfix
</a></li><li class="dropdown-item"><!----> <a href="/categories/博文/" class="nav-link"><i class="iconfont undefined"></i>
  博文
</a></li><li class="dropdown-item"><!----> <a href="/categories/Life perception/" class="nav-link"><i class="iconfont undefined"></i>
  Life perception
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/notes/" class="nav-link router-link-active"><i class="iconfont reco-document"></i>
  Notes
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/Interview/" class="nav-link"><i class="iconfont reco-blog"></i>
  Interview
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-account"></i>
      About
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/recoluan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Html5</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Css3</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/Javascript/javascript_basis.html" class="sidebar-link">JavaScript (basis)</a></li><li><a href="/notes/Javascript/javascript_max.html" aria-current="page" class="active sidebar-link">JavaScript[max]</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e></h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>KivenXue</span>
            
          <!---->
          2020
        </a></span></div></div> <div data-v-2d5f533b><main class="page"><div class="page-title" style="display:none;"><h1 class="title">JavaScript[max]</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>KivenXue</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2020-10-24</span></i> <!----> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>JavaScript[max]</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><h1 id="javascript-max"><a href="#javascript-max" class="header-anchor">#</a> JavaScript[max]</h1> <h2 id="正则表达式用于"><a href="#正则表达式用于" class="header-anchor">#</a> 正则表达式用于</h2> <p>概述  正则表达式 专门描述字符串中字符串出现规则的表达式</p> <p>正则表达式用于:</p> <ol><li>验证字符串格式</li> <li>查找敏感词</li></ol> <h2 id="定义正则表达式"><a href="#定义正则表达式" class="header-anchor">#</a> 定义正则表达式</h2> <ul><li><h3 id="使用字符集简写"><a href="#使用字符集简写" class="header-anchor">#</a> 使用字符集简写</h3> <ul><li>多选一规则匹配
[备选方案]
[卧我]
[0-9] 区间内选一</li></ul></li> <li><h2 id="其他简写"><a href="#其他简写" class="header-anchor">#</a> 其他简写</h2> <ol><li>匹配一位小写音文字母 [a-z] 共26个</li> <li>匹配一位大写音文字母 [A-Z] 共26个</li> <li>要匹配一位字母 [A-Za-z] 共52个</li> <li>要匹配一位字母或数字 [0-9A-Za-z] 共62个</li> <li>要匹配一位汉字 [\u4e00-\u9fa5] 19968~40869 共20902个</li></ol> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>      例子<span class="token operator">:</span>
      利用字符集简写定义车牌号规则
      <span class="token number">1.</span> 第一位  <span class="token number">1</span>位汉字
      <span class="token number">2.</span> 第二位  <span class="token number">1</span>位大写字母
      <span class="token number">3.</span> 第三位   <span class="token punctuation">.</span>
      <span class="token number">4.</span> 后五位  每一位 都是一位大写字母或数字 
  
      答案<span class="token operator">:</span><span class="token punctuation">[</span>\u4e00<span class="token operator">-</span>\u9fa5<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token constant">A</span><span class="token operator">-</span><span class="token constant">Z</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span>A<span class="token operator">-</span><span class="token constant">Z</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span>A<span class="token operator">-</span><span class="token constant">Z</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span>A<span class="token operator">-</span><span class="token constant">Z</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span>A<span class="token operator">-</span><span class="token constant">Z</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span>A<span class="token operator">-</span><span class="token constant">Z</span><span class="token punctuation">]</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><h3 id="预定义字符集"><a href="#预定义字符集" class="header-anchor">#</a> 预定义字符集</h3> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token operator">-</span> 要匹配一位数字<span class="token operator">:</span> \d 等效于<span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token operator">-</span> 要匹配一位字母<span class="token punctuation">,</span>数字或<span class="token operator">:</span>\w 等效于 <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span>A<span class="token operator">-</span>Za<span class="token operator">-</span>z<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token operator">-</span> 要匹配一位空字符 \s 可匹配 空格<span class="token punctuation">,</span>制表符Tab 等 空白
<span class="token operator">-</span> <span class="token function">要匹配所有</span><span class="token punctuation">(</span>通配符<span class="token punctuation">)</span>  <span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ul> <p>手机号规则可进一步简写:
1[3-8]\d\d\d\d\d\d\d\d\d</p> <ul><li><h1 id="数量词"><a href="#数量词" class="header-anchor">#</a> 数量词</h1> <ul><li>手机号实例   \d{9} 等同于 \d * 9 次
例 : [3-9]\d{9}</li> <li>车牌号简写
例 : [\u4e00-\u9fa5][A-Z].[A-Z0-9]{5}</li></ul></li> <li><h3 id="数量词-包含两大类"><a href="#数量词-包含两大类" class="header-anchor">#</a> 数量词 包含两大类</h3> <ol><li>有明确数量边界的数量词</li></ol> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>      <span class="token operator">-</span> 字符集<span class="token punctuation">{</span>n<span class="token punctuation">}</span> 表示字符集必须重复n次 不能多也不能少
      <span class="token operator">-</span> 字符集<span class="token punctuation">{</span>n<span class="token punctuation">,</span>m<span class="token punctuation">}</span> 表示字符集至少重复n次 最多重复 m 次
        比如： \d<span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">}</span>
      <span class="token operator">-</span> 字符集<span class="token punctuation">{</span>n<span class="token punctuation">,</span><span class="token punctuation">}</span>表示字符集匹配内容至少 重复n 次 多了不限
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="2"><li><p>没有明确数量边界的数量词</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token operator">-</span> \<span class="token operator">*</span> 可有可无 多了不限
<span class="token operator">-</span> ？ 可有可无 最多一次
<span class="token operator">-</span> \<span class="token operator">+</span>  至少一次 多了不限
<span class="token operator">-</span> \s<span class="token operator">*</span>   \s<span class="token operator">+</span>  \s<span class="token operator">?</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ol></li></ul> <ul><li><p>例子:
匹配手机短信中验证码  连续4为 到 6位的手机号</p> <p>正则表达式 大部分情况采用 贪婪模式进行匹配
尽量匹配最长的关键词</p></li></ul> <ul><li><h2 id="选择和分组"><a href="#选择和分组" class="header-anchor">#</a> 选择和分组</h2> <ol><li><p>选择 指多个子规则选择其一进行匹配</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code> 子选择<span class="token number">1</span> <span class="token operator">|</span> 子选择<span class="token number">2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>1.  分组 多个子规则分为一组 再和分组外的规则匹配

​```JS
其他规则(多个子规则)

例: ([我卧]|wo)\s*([草艹槽]|cao)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="2"><li><p>定义完整手机号规则</p> <div class="language- extra-class"><pre><code> - +86 或 0086
 - (\+86|0086)
 - 至少一个空字符:\s+ 
 - 之前所有可有可无 至少一次()?
 - 1 
</code></pre></div><ul><li>3~8 任选其一
<ul><li>0-8
\+ 转义字符
答案: ((+86|0086)\s+)?1[3-8]/d{9}</li></ul></li></ul></li> <li><p>定义完整身份证号规则</p> <div class="language- extra-class"><pre><code> - 15位数字 \d{15}
 - 2位数字 \d\d
 - 最后一位:  1位数字 或 X[0-9x]
 - 最后三位 可有可无 虽多一次

 定义完整身份证正则
 \d{15}(\d\d[0-9x])?
</code></pre></div></li></ol></li></ul> <p>作业需求:  匹配 &quot;微信&quot;,&quot;weixin&quot;,&quot;w x&quot; 等情况 并防止 中间加空格</p> <ul><li><h2 id="指定匹配位置"><a href="#指定匹配位置" class="header-anchor">#</a> 指定匹配位置</h2> <ul><li><p>使用情况  如果只希望匹配特殊位置上的关键词时 就可以使用特殊符号 表示特殊位置</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> <span class="token operator">^</span> 表示字符串开头  
<span class="token number">2.</span> $ 表示字符串结尾
<span class="token number">3.</span> \b 表示单词边界<span class="token punctuation">,</span>可匹配<span class="token operator">:</span> 空格 标点符号 字符串开头和结尾等 可将一个单词与其他单词分割开的符号
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul> <p>找到开头和结尾空格</p> <p>例如 ^\s+$ //错误写法</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>      正确写法     
     <span class="token operator">^</span>\s<span class="token operator">+</span><span class="token operator">|</span>\s<span class="token operator">+</span>$
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li><p>常见面试题</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token operator">-</span> 找到每个单词的首字母
<span class="token operator">-</span> ———— 前边紧挨着的单词边界字母
<span class="token operator">^</span>\b<span class="token punctuation">[</span><span class="token constant">A</span><span class="token operator">-</span>Za<span class="token operator">-</span>z<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul></li></ul> <p>作业需求</p> <p>使用正则匹配电子邮件: ___ 记住</p> <ul><li><h2 id="string-的正则函数"><a href="#string-的正则函数" class="header-anchor">#</a> String 的正则函数</h2> <ul><li><p>查找敏感词  4种情况</p> <ul><li><p>1 查找一个固定的敏感词位置 i;</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> i<span class="token operator">=</span>str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;敏感词&quot;</span><span class="token punctuation">,</span>fromi<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在str中 从 fromi 开始 向后查找下一个“敏感词”的下标位置 i</p> <p>找到 返回敏感词第一个字的下标位置
没找到返回 -1</p> <p>问题: indexOf 只能查找固定的敏感词 而且不支持正则！</p></li> <li><p>2  用正则表达式 模糊查找多种敏感词</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token operator">-</span>  <span class="token keyword">var</span> i <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">正则</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">)</span>
  <span class="token operator">-</span>  i 不区分大小写
  <span class="token operator">-</span> 原理和用法几乎相同
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>差别
- 1 用灵活的正则表达式 代替了写死的敏感词
- 2 只有一个参数 不能指定开始的位置 永远只能从头开始找</p></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul></li> <li><h2 id="扩展-test"><a href="#扩展-test" class="header-anchor">#</a> 扩展 .test()</h2> <ul><li><p>test() 方法是正则表达式的一个方法，用于检测一个字符串是否匹配某个模式</p></li> <li><p>如果是则返回 true，否则就返回 false</p></li> <li><p>regexp.test(str)</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>手机号验证：<span class="token operator">!</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[1][3,4,5,7,8][0-9]{9}$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>phone<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul></li></ul> <hr> <h1 id="string-正则函数"><a href="#string-正则函数" class="header-anchor">#</a> String 正则函数</h1> <h2 id="查找敏感词"><a href="#查找敏感词" class="header-anchor">#</a> 查找敏感词</h2> <p>4种</p> <ol><li><p>固定敏感词出现的位置</p> <div class="language- extra-class"><pre><code>   ````JS
     var i = str.indexOf(&quot;敏感词&quot;,fromi);
   ````
</code></pre></div></li></ol> <p>没有给定值 从0开始找
没找到返回-1
问题： 如果换成同音字或拼音,就找不到了</p> <ol start="2"><li><p>用正则表达式模糊查找一个敏感词的位置</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> i<span class="token operator">=</span>str<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">正则表达式</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>问题：只能返回敏感词的位置 不能返回敏感词具体的内容</p></li> <li><p>获取敏感词内容 2种</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">正则</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language- extra-class"><pre><code> - 在str中 查找一个符合正则要求的敏感词的内容和位置

 - 返回值 返回一个数组 

 - 没找到 返回null 

 - 如果想获得本次查找的内容 arr[0]  

 - 如果想获得本次查找的位置  arr

   `````JS
   [&quot;index&quot;] 必须添加 &quot;&quot;
   `````

 正则表达式只能匹配一个敏感词 -g 找出所有
</code></pre></div><div class="language-JS line-numbers-mode"><pre class="language-js"><code>  str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token comment">//ig);</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-JS line-numbers-mode"><pre class="language-js"><code>问题<span class="token operator">:</span>  如果match<span class="token operator">+</span>g 只能返回敏感词内容 无法返回敏感词位置 
如果只关心 敏感词内容  就使用 match<span class="token operator">+</span>g 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ol> <h2 id="强调"><a href="#强调" class="header-anchor">#</a> 强调</h2> <ul><li><h4 id="如果一个函数有可能返回null-则使用前必须先验证-是不是null-才能使用-因为null之后-什么都不可以加-null-报错-null-报错"><a href="#如果一个函数有可能返回null-则使用前必须先验证-是不是null-才能使用-因为null之后-什么都不可以加-null-报错-null-报错" class="header-anchor">#</a> 如果一个函数有可能返回null! 则使用前必须先验证 是不是null 才能使用  因为null之后 什么都不可以加 null 报错 null. 报错</h4></li> <li><div class="language-JS line-numbers-mode"><pre class="language-js"><code>$<span class="token punctuation">{</span>arr<span class="token operator">!=</span><span class="token keyword">null</span><span class="token operator">?</span>arr<span class="token punctuation">.</span>length<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h1 id="js-底层数组都是关联数组"><a href="#js-底层数组都是关联数组" class="header-anchor">#</a> Js 底层数组都是关联数组  &quot;&quot; : &quot;&quot;</h1> <h3 id="arr-length-arr-length-数字下标不能简写-与小数点冲突"><a href="#arr-length-arr-length-数字下标不能简写-与小数点冲突" class="header-anchor">#</a> arr.length arr[&quot;length&quot;]  数字下标不能简写!  与小数点冲突</h3> <ol start="4"><li><p>既查找每个关键词的内容 又查找关键词的位置</p> <div class="language- extra-class"><pre><code>   - RegExp对象 exec() 函数
</code></pre></div></li></ol> <h1 id="替换敏感词"><a href="#替换敏感词" class="header-anchor">#</a> 替换敏感词</h1> <ol><li><p>简单替换 将所有敏感词替换统一新词</p> <div class="language- extra-class"><pre><code>````JS
  str = str.replace(/正则/ig,&quot;新词&quot;)
````

   坑： 替换后 不报错也替换不成功
    
   因为 字符串都是不可变类型 ！
        无法对原字符串直接进行修改
        所有字符串函数 都只能返回修改后的字符串 而保持原字符串不变
   解决 想要获得新值 必须用=接住新值保存到变量中
</code></pre></div></li> <li><p>高级替换 根据每次找到的敏感词不同 动态选择不同的新词替换！</p> <div class="language- extra-class"><pre><code> //replace 会自动在每个找到的关键词上调用一次这个

//回调函数 找到几个词 就反复调用几次 每次调用时 会

//自动将本次找到的关键词传给函数keyword
</code></pre></div></li></ol> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token number">2</span>个要求
                
      <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">keyword</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token number">1</span> 必须有一个参数接住本次找到的一个关键词
      
         <span class="token number">2</span> 必须返回处理后的新词
            <span class="token keyword">return</span> keyword<span class="token punctuation">.</span><span class="token function">toLocaleUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          
所有形参可自己定义参数名
补 回调函数 callback 我们自己定义的 但不是我们自己调用去执行 而是交给其他对象去执行
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>衍生：删除敏感词 其实就是将敏感词替换为&quot;&quot;</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>    <span class="token keyword">function</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\s+|\s+$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="3"><li>切割敏感词</li></ol> <p>什么是 根据指定的切割符 切割成多段字符串</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token number">2</span>种<span class="token operator">:</span> 

    <span class="token number">1.</span> 简单切割  切割符是固定的
       <span class="token operator">-</span> <span class="token keyword">var</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;切割符&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token operator">*</span> 将字符串 str 
    
    <span class="token number">2.</span> 复杂切割 <span class="token operator">:</span> 切割符是变化的 但是有规律的。 
    
       <span class="token operator">-</span> <span class="token keyword">var</span> arr<span class="token operator">=</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">正则</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span>
    
       <span class="token operator">-</span> 例如按照空格进行分割
    
     <span class="token operator">-</span> 衍深操作：打撒字符串为字符数组
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li>总结：
<ul><li><p>查找敏感词</p> <ul><li><ol><li><p>查找一个固定的敏感词</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;敏感词&quot;</span><span class="token punctuation">,</span>fromi<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol></li> <li><ol start="2"><li><p>使用正则模糊查找一个敏感词位置</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code></code></pre> <div class="line-numbers-wrapper"></div></div></li></ol>
str.search(/正则/i)<div class="language- line-numbers-mode"><pre class="language-text"><code></code></pre> <div class="line-numbers-wrapper"></div></div></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><ol start="3"><li>用正则查找一个敏感词的内容</li></ol></li> <li><ol><li><p>只查找一个敏感词的位置 和内容</p> <div class="language- extra-class"><pre><code>      ```JS
      var arr = str.match(/正则/i)
      ```
</code></pre></div></li></ol></li> <li><ol start="2"><li><p>查找全部敏感词内容 但无法获取位置</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token comment">//ig);</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><ol start="4"><li>既查找每个敏感词内容 又查找每个敏感词的位置</li></ol></li></ul></li></ol></li></ul></li></ul> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>  <span class="token operator">-</span> 替换敏感词
      <span class="token operator">-</span> 删除
  <span class="token operator">-</span> 切割
      <span class="token operator">-</span> 打撒字符串为字符数组
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="regexp对象"><a href="#regexp对象" class="header-anchor">#</a> RegExp对象:</h2> <ul><li><p>专门保存一条正则表达式 并提供正则执行查找和验证方法的对象
何时:</p> <ol><li>验证时</li> <li>高级查找时
如何:</li> <li>创建对象:2种
<ol><li><p>简化版创建</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token operator">/</span>\b<span class="token punctuation">[</span>a<span class="token operator">-</span>z<span class="token punctuation">]</span>ig<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol></li></ol> <p>何时 如果正则表达式固定不变的w
问题 不支持动态生成正则表达式
因为://之间是正则表达式的地盘 js不认识</p></li></ul> <div class="language- extra-class"><pre><code>2. 用new创建
  
    ```JS
  var reg = RegExp(&quot;\b[a-z]&quot;,&quot;ig&quot;);
         ```

     何时  如果正则表达式需要根据变量数组内容 动态生成！
         
         因为：这种方法用js认识的&quot;&quot;代替了// 而在js中 有很多办法 灵活的拼接想要的字符串 
</code></pre></div><p>​<br>
​<br>
2. RegExp
1. 验证格式</p> <div class="language- extra-class"><pre><code>        ````JS
        var bool = reg.test(str);
        ````
  
    用reg规则 检测str 是否符合规则要求 
    返回值：true/false
  
    坑: test 默认只要在str 中找到部分 和 reg 匹配的 就返回true ！ 而不要求 从头到尾匹配
</code></pre></div><p>​<br>
## 解决：凡是验证 都要求从头到尾必须完整匹配</p> <div class="language- extra-class"><pre><code>        前加 ^ 结尾加 $ 
  
  意味从头到尾
</code></pre></div><p>​<br>
只要使用test 必须使用 前后+^$</p> <h1 id="regexp"><a href="#regexp" class="header-anchor">#</a> RegExp :</h1> <ol><li><p>验正字符串格式 bool= reg.test();</p></li> <li><p>既查找内容 有查找关键词的位置</p> <p>var arr = reg.exec(str);</p></li></ol> <div class="language- extra-class"><pre><code> 在str 中查找下一个关键词的位置和内容
      
  返回值 和match 不加 g 的时候是相同的
        直到到 arr[0:关键词的内容,index: 位置]
        如果没有找到返回null
</code></pre></div><h1 id="function"><a href="#function" class="header-anchor">#</a> Function</h1> <h2 id="什么是"><a href="#什么是" class="header-anchor">#</a> 什么是：</h2> <p>用途 保存一段可重用的代码段的程序结构 再起一个名字</p> <p>本质 内存中保存一段代码段的存储空间--</p> <h2 id="为什么"><a href="#为什么" class="header-anchor">#</a> 为什么：</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>代码重用
何时 只要一段代码 可能被反复使用 都要定义在一个函数内 再起个名字 今后 用函数名等于用代码段
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如何</p> <p>创建函数 3种</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> <span class="token keyword">function</span> <span class="token function">函数名</span> <span class="token punctuation">(</span><span class="token parameter">形参列表</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    函数体
    <span class="token keyword">return</span> 返回值
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>形参是什么</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>          专门接受 从函数外部传入函数内部数据的变量
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>为什么</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>          有些函数执行时  需要动态获得必须的数据 才能正常执行
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>何时</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>          只要一个函数 必须某些数据 才能正确执行
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>返回值</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>      什么是  一个函数的执行结果
      
      为什么 外部调用者可能需要获得函数执行结果
      
      何时   只要外部调用者 需要获的函数的执行结果
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>笔试问题</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>问题  会被声明提前
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>什么是</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>  在程序执行前！程序会先将所有<span class="token keyword">var</span> 声明的变量和<span class="token keyword">function</span>声明的函数 提前到当前作用域的顶部集中创建 <span class="token function">而</span><span class="token punctuation">(</span>赋值<span class="token operator">=</span><span class="token punctuation">)</span>留在原地
  所以声明提前是js广受诟病的缺陷
  打乱了程序正常执行的顺序
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="2"><li><p>new 来创建</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>  <span class="token keyword">var</span> fun <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&quot;形参1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;形参2&quot;</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>赋值方式创建：</p></li></ol> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">函数名</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">形参列表</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    函数体
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>说明: 赋值方式创建的函数 和声明方式 创建的函数在使用时 都一样
只不过 在程序开始执行前 赋值方式可避免函数被声明提前 保持了程序原有的执行顺序</p> <p>揭示: js中其实函数也是一个普通的对象而已,函数名仅仅是一个普通的变量 函数名变量通过对象地址引用着函数对象,每次调用函数名时 通过地址 找到函数对象 再执行其中内容</p> <p>变量 : 内存中存储一个数据的存储空间 在起一个名字</p> <p>强调 如果一个函数 只是定义 没有调用 该函数体是不会执行</p> <p>global[&quot;a&quot;];  底层  关联数组</p> <h2 id="重载-overload"><a href="#重载-overload" class="header-anchor">#</a> 重载(overload)</h2> <h3 id="什么是-2"><a href="#什么是-2" class="header-anchor">#</a> 什么是:</h3> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>  多个同名函数 不同形参列表 在调用时根据传入实参列表的不同 动态选择函数执行 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="为什么-2"><a href="#为什么-2" class="header-anchor">#</a> 为什么</h3> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>  减少函数个数 减轻调用者的负担
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="何时"><a href="#何时" class="header-anchor">#</a> 何时</h3> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>  只要一件事 可能根据传入参数的不同  执行不同的逻辑 都要使用重载！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="如何"><a href="#如何" class="header-anchor">#</a> 如何:</h3> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>  问题Js不支持标准的重载写法 因为js不允许多个同名函数的存在！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="解决"><a href="#解决" class="header-anchor">#</a> 解决:</h3> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>    js中借助于arguments 对象实现重载
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="什么是-3"><a href="#什么是-3" class="header-anchor">#</a> 什么是:</h3> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>每个函数内自带的 专门接收所有传入函数的实参值列表的数组对象。

函数内自带对象 不用创建可直接拿来使用 接收所有传入函数的实参值 即使没有定义形参变量 或形参变量个数少于传入实参值个数 都没关系

arguments 可接住所有传入函数的实参值 这就是为什么js 中的函数 定义了几个形参和调用了几个实参 毫无关系
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="类数组对象"><a href="#类数组对象" class="header-anchor">#</a> 类数组对象:</h2> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>长得像数组的对象
像数组 <span class="token number">1</span> 小标 <span class="token number">2</span> length
不是数组 是对象 不是数组家孩子
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="何时-2"><a href="#何时-2" class="header-anchor">#</a> 何时:</h3> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>  只要js中接收不确定个数的参数值 都用arguments<span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="如何-2"><a href="#如何-2" class="header-anchor">#</a> 如何:</h3> <div class="language-JS line-numbers-mode"><pre class="language-js"><code>  <span class="token number">1</span> 无论传入多少个参数 都只定义一个函数 
  <span class="token number">2</span> 在函数内直接访问 arguments 根据 arguments 不同 动态选择不同的逻辑执行任务。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果只是部分参数不确定 而且参数赋值给参数时 又要求对应关系怎么办？</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token function">cook</span><span class="token punctuation">(</span><span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token string">&quot;面&quot;</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>答: 以上传参方式 会报语法错误！因为实参列表不允许出现空值</p> <h3 id="当遇到多个参数不确定有没有-又要要求对应关系时-只能使用对象语法解决"><a href="#当遇到多个参数不确定有没有-又要要求对应关系时-只能使用对象语法解决" class="header-anchor">#</a> 当遇到多个参数不确定有没有 又要要求对应关系时 只能使用对象语法解决</h3> <p>1 定义函数时:</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">函数</span><span class="token punctuation">(</span><span class="token parameter">形参列表变量</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 先判断 obj 对象包含那些属性 不包含那些属性 缺少的属性用默认值代替</span>
    <span class="token comment">// 函数执行过程中 都从对象里,取实参值使用！</span>
<span class="token punctuation">}</span> 

但是<span class="token punctuation">,</span> 我们规定 在将来调用时 实参值都要放在一个对象中传入
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>2  调用函数时:</p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token function">函数名</span><span class="token punctuation">(</span><span class="token punctuation">{</span>属性<span class="token number">1</span><span class="token operator">:</span>实参值<span class="token number">1</span>，<span class="token punctuation">,</span>属性<span class="token number">2</span><span class="token operator">:</span>实参值<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="优点-任意参数都可以缺少-都不会报错"><a href="#优点-任意参数都可以缺少-都不会报错" class="header-anchor">#</a> 优点: 任意参数都可以缺少 都不会报错</h2> <p>任意参数求和</p> <h2 id="匿名函数"><a href="#匿名函数" class="header-anchor">#</a> 匿名函数</h2> <h2 id="什么是-4"><a href="#什么是-4" class="header-anchor">#</a> 什么是：</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    定义函数时 <span class="token function">不被任何变量所引用的函数</span>  
      <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="为什么-3"><a href="#为什么-3" class="header-anchor">#</a> 为什么：</h2> <h3 id="_1-为了节约内存-2-划分临时作用域"><a href="#_1-为了节约内存-2-划分临时作用域" class="header-anchor">#</a> 1 为了节约内存 2 划分临时作用域！</h3> <p>何时：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    <span class="token number">1.</span> 如果一个函数只执行一次 
    <span class="token number">2.</span> 划分临时作用域！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如何:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    <span class="token number">1.</span> 回调函数<span class="token operator">:</span> 今后大多为匿名函数
    <span class="token number">2.</span> 匿名函数自调
    <span class="token number">1.</span> 为什么  全局变量 极易被污染！ 今后禁止使用全局变量 <span class="token operator">!</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>匿名函数自调 定义函数后 立即调用函数 调用后立即释放！</p> <p>问题 全局变量极易被污染！又不会自动释放 所以 今后禁止使用全局变量</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>解决 今后js 代码 都要包裹在匿名函数自调用中 
好处 绝对不会产生全局变量 节约内存又不影响功能执行
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h1 id="作用域和作用域链"><a href="#作用域和作用域链" class="header-anchor">#</a> 作用域和作用域链</h1> <h2 id="作用域-scope"><a href="#作用域-scope" class="header-anchor">#</a> 作用域(scope):</h2> <h3 id="什么是-5"><a href="#什么是-5" class="header-anchor">#</a> 什么是</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>用途<span class="token operator">:</span> 作用域就是一个变量的可用范围
本质：作用域是保存变量的一个对象
为什么： 为了避免不同范围得变量互相干扰<span class="token operator">!</span>
包括 <span class="token constant">JS</span>中只包括<span class="token number">2</span>级作用域
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="全局作用域"><a href="#全局作用域" class="header-anchor">#</a> 全局作用域：</h3> <div class="language- extra-class"><pre><code>             1. 保存任何地方都可以访问到的变量区域
                   量称为全局变量 
             2. 全局变量优点 共用 可反复使用 
                    浪费内存
             3.  函数作用域
                   ​                1. 保存在函数内才可以使用的变量区域
                   ​                2. 函数作用域中保存的变量是局部变量 
                   ​                3. 局部变量优点 仅函数内可用 不会污染全局且用完就释放  不占用内存 
                   ​                4. 缺点 无法重用！
</code></pre></div><h2 id="程序和函数的执行过程"><a href="#程序和函数的执行过程" class="header-anchor">#</a> 程序和函数的执行过程：</h2> <ol><li>当程序执行时 先创建全局作用域对象window</li></ol> <p>​	在window中 先保存所有的全局变量 和全局 函数
​</p> <ol start="2"><li><p>当定义函数时 每个函数其实都有一个好友列表 暂时包含两项 离自己最近的一项是暂时是空的  距离自己远一些的一项保存着指向window 对象的地址</p></li> <li><p>&quot;好友列表&quot;作用是 将来调用函数时,万一缺变量,可按照好友列表的顺序 去朋友中寻找</p></li></ol> <p>当调用函数时 会临时创建这次调用函数的函数作用域对象 并在函数作用域对象中添加函数的局部变量 并将函数作用域对象的引用 假如函数的好友列表中最近的一项保存！说明函数和临时创建的函数作用域对象 关系最好！ 缺变量 先找临时创建的函数作用域对象  如果函数作用域对象没有 才被迫找window要</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>当函数调用后 临时创建的函数作用域对象被释放 函数作用域对象中的变量同时释放 —————— 这就是为什么局部变量不可重用 的原因！！！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="作用域链-scopes"><a href="#作用域链-scopes" class="header-anchor">#</a> 作用域链(scopes)</h2> <p>什么是:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>一个函数可用的所有作用域对象的集合。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>普通函数的作用链 在调用时是两个成员</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 距离自己最近的是临时创建的函数作用域对象
<span class="token number">2.</span>  离自己稍微远一些的是全局作用域对象 window
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>一个函数的作用域链</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>  保存着这个函数可用的所有变量
<span class="token number">2.</span>  控制这变量的使用顺序

先局部 后全局
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h1 id="闭包-closure"><a href="#闭包-closure" class="header-anchor">#</a> 闭包(closure)</h1> <h2 id="什么是闭包"><a href="#什么是闭包" class="header-anchor">#</a> 什么是闭包：</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>用途<span class="token operator">:</span> 

  既重用一个变量 有保护这个变量不被污染的一种编程方法

本质<span class="token operator">:</span> 
    
    外层函数的作用域对象 被内层函数对象引用着 无法释放  这个外层函数的作用域就是闭包对象

为什么<span class="token operator">:</span> 

    全局变量和局部变量的优缺点
    全局变量<span class="token operator">:</span> 优点 可重用 缺点 极易被污染！<span class="token punctuation">;</span>
    局部变量：优点  不会被污染 缺点<span class="token operator">:</span>不可重用！<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="何时-3"><a href="#何时-3" class="header-anchor">#</a> 何时：</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  今后 只要为一个函数保存一个专属的 可重用的 还不会被外部污染的变量
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="如何-4步"><a href="#如何-4步" class="header-anchor">#</a> 如何：4步</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>        <span class="token number">1.</span> 外层函数包裹要保护的变量和内层函数
           内层函数一定要使用了外层函数的局部变量
        <span class="token number">2.</span> 外层函数将内层函数抛到外部
        <span class="token number">3.</span> 调用者调用外层函数 获得返回的内层函数对象 保存在变量中。 并反复使用。
        <span class="token number">4.</span> 外层定义一个变量接收<span class="token keyword">return</span>出的参数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>闭包是如何形成的</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  外层函数作用域对象<span class="token punctuation">,</span>被内层函数对象引用着无法释放
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>闭包的缺点</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 比普通函数占用更多内存
<span class="token number">2.</span> 多占用父母函数作用域对象
<span class="token number">3.</span> 闭包不会自动释放 可能造成内存泄漏
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>解决: 使用完闭包后 如果不在使用了 要手动释放闭包</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code>pay <span class="token operator">=</span> <span class="token keyword">null</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>定义一个取号机函数 getNum() 可反复输出一个递增的不重复的数字</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span>
<span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2</span>
<span class="token comment">//试图用同名变量篡改序号为0</span>
xxx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3</span>



<span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">999</span>
    <span class="token function-variable function">nAdd</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>n<span class="token operator">++</span><span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> getN <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//?</span>
<span class="token function">nAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//?</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><hr> <h1 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h1> <h2 id="什么是对象"><a href="#什么是对象" class="header-anchor">#</a> 什么是对象:</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>用途<span class="token operator">:</span> 对象是描述现实中一个具体事物的属性和功能的程序结构

本质： 程序中集中存储一个事物的属性和功能的一块存储空间 再起一个名字
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="为什么-4"><a href="#为什么-4" class="header-anchor">#</a> 为什么：</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  便于大量数据的维护和使用
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="什么是面向对象编程"><a href="#什么是面向对象编程" class="header-anchor">#</a> 什么是面向对象编程：</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  程序都是先将数据封装在对象中 然后再按需使用对象中的成员。 这样的编程方式 就是面向的对象编程
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="何时-4"><a href="#何时-4" class="header-anchor">#</a> 何时:</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  今后所有程序都是用面向对象方式实现的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="如何-3"><a href="#如何-3" class="header-anchor">#</a> 如何：</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>面向对象三步<span class="token operator">/</span>三大特点<span class="token operator">:</span> 封装 继承 多态
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h1 id="封装-继承-多态"><a href="#封装-继承-多态" class="header-anchor">#</a> 封装 继承 多态</h1> <h2 id="封装"><a href="#封装" class="header-anchor">#</a> 封装：</h2> <h3 id="什么是-6"><a href="#什么是-6" class="header-anchor">#</a> 什么是：</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  创建一个对象 集中保存一个事物的属性和功能
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="何时-5"><a href="#何时-5" class="header-anchor">#</a> 何时：</h3> <div class="language-json line-numbers-mode"><pre class="language-json"><code>  - 只要使用面向对象方式编程 都要先将数据和功能封装在对象中 然后再按需使用。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="如何3种"><a href="#如何3种" class="header-anchor">#</a> 如何3种：</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>用<span class="token punctuation">{</span><span class="token punctuation">}</span> 创建一个对象

    <span class="token keyword">var</span> 对象名<span class="token operator">=</span><span class="token punctuation">{</span>
        属性名<span class="token operator">:</span>值<span class="token punctuation">,</span>
        <span class="token operator">...</span><span class="token punctuation">.</span>
        <span class="token function-variable function">方法</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="如何访问"><a href="#如何访问" class="header-anchor">#</a> 如何访问</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>对象名<span class="token punctuation">.</span>属性名
对象名<span class="token punctuation">.</span><span class="token function">方法</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="问题"><a href="#问题" class="header-anchor">#</a> 问题：</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  在对象自己的方法 直接使用属性名却无法访问到自己的属性 报错 属性名未定义
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="原因"><a href="#原因" class="header-anchor">#</a> 原因</h3> <div class="language-json line-numbers-mode"><pre class="language-json"><code>  所有不带.的变量<span class="token punctuation">,</span>默认只能在作用域链中(临时函数作用域和我window)查找。 但是对象中<span class="token punctuation">{</span><span class="token punctuation">}</span>又不是作用域 所以对象是不包含在作用域链中的 所以直接使用属性<span class="token punctuation">,</span>无法找到藏在对象内的属性的。 不好的解决方法：在属性名前加对象. <span class="token punctuation">,</span>勾引着引擎进入对象中查找属性。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="问题-2"><a href="#问题-2" class="header-anchor">#</a> 问题：</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>紧耦合 如果外部修改 内部被迫跟着修改
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="解决-2"><a href="#解决-2" class="header-anchor">#</a> 解决:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>松耦合 外部改变 内部d代码不用改变 也能自动适应
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="this-属性名"><a href="#this-属性名" class="header-anchor">#</a> This.属性名</h2> <h3 id="什么是this"><a href="#什么是this" class="header-anchor">#</a> 什么是this:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  在调用函数时 临时指向正在调用函数的<span class="token punctuation">.</span>前对象的关键词

  总结 只要是自己的方法 想访问自己的属性就使用<span class="token keyword">this</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="错误"><a href="#错误" class="header-anchor">#</a> 错误：</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>函数定义在哪个对象中 <span class="token keyword">this</span>就指向哪个对象 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="正确"><a href="#正确" class="header-anchor">#</a> 正确：</h3> <p>this与函数定义在哪无关！只与函数调用这一瞬间.前对象有关</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    <span class="token number">2.</span>   用<span class="token keyword">new</span>创建：<span class="token number">2</span>步
            <span class="token number">1.</span>   先创建空对象 <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token number">2.</span>  强行向空对象中添加新属性  
                <span class="token number">1.</span>  obj<span class="token punctuation">.</span>属性 <span class="token operator">=</span> 值
                <span class="token number">2.</span>  obj<span class="token punctuation">.</span><span class="token function-variable function">方法</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
            揭示： 所有js对象底层 都是关联数组。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="对象-vs-关联数组"><a href="#对象-vs-关联数组" class="header-anchor">#</a> 对象 VS 关联数组</h2> <h3 id="相同-4-个"><a href="#相同-4-个" class="header-anchor">#</a> 相同 4 个</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 都可以用<span class="token punctuation">[</span><span class="token string">&quot;成员名&quot;</span><span class="token punctuation">]</span>或<span class="token punctuation">.</span>成员名两种方式 访问自己的成员。 <span class="token punctuation">.</span>成员名 其实就是<span class="token punctuation">[</span><span class="token string">&quot;成员名&quot;</span><span class="token punctuation">]</span> 简写 也就是说 <span class="token punctuation">.</span>成员名 到底层会被自动翻译成<span class="token punctuation">[</span><span class="token string">&quot;成员名&quot;</span><span class="token punctuation">]</span>

    坑 如果成员名来自于一个变量！ 则不能用<span class="token string">&quot;.变量&quot;</span>方式访问成员。因为<span class="token punctuation">.</span><span class="token string">&quot;变量&quot;</span> 会被翻译为<span class="token punctuation">[</span><span class="token string">&quot;变量&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 出错了 因为变量不可以放在<span class="token string">&quot;&quot;</span>里！
    解决<span class="token operator">:</span> 今后只要成员名不是写死的，而是来自于一个变量 只能用<span class="token punctuation">[</span>变量<span class="token punctuation">]</span><span class="token punctuation">,</span> 不带引号的方式访问

<span class="token number">2.</span> 都可以被<span class="token keyword">for</span> <span class="token keyword">in</span>循环遍历每个成员

<span class="token number">3.</span>  随时可以给数组或对象在任何位置添加新成员<span class="token punctuation">,</span>而不会报错！ 而自动创建该成员
所以 如果想给一个已创建玩得对象 添加新属性 只有一个野蛮的办法 强行赋值！

<span class="token number">4.</span>  访问数组或对象中不存在的位置 不会报错 而是返回<span class="token keyword">undefined</span>！

    不同 类型
    关联数组<span class="token operator">:</span> 是数组家的孩子
    对象 是object 孩子
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>问题:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  只能创建一个对象 如果反复创建 多个相同结构的对象时。
  代码很冗余 不便于维护。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>解决:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>用构造函数：
什么是： 专门描述一类对象统一结构的函数
为什么<span class="token operator">:</span>  为了重用对象的结构定义 
何时： 只要程序中需要反复创建 同一类型的多个对象时。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="构造函数"><a href="#构造函数" class="header-anchor">#</a> 构造函数</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  如何<span class="token operator">:</span> <span class="token number">2</span>步
    <span class="token number">1.</span> 定义构造函数来描述一类对象同意结构
        <span class="token keyword">function</span> <span class="token function">类型名</span><span class="token punctuation">(</span><span class="token parameter">形参<span class="token number">1</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>属性名 <span class="token operator">=</span> 形参<span class="token number">1</span><span class="token punctuation">;</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>属性名<span class="token operator">...</span>形参<span class="token number">1</span><span class="token punctuation">;</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">方法</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token number">2.</span> 调用构造函数按照统一结构创建对象  
        <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">类型名</span><span class="token punctuation">(</span>属性值<span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
        <span class="token keyword">new</span> 的 原理：<span class="token number">4</span>件事<span class="token punctuation">;</span>
            <span class="token number">1.</span> 新建一个空对象
            <span class="token number">2.</span> ？
            <span class="token number">3.</span> 用<span class="token keyword">new</span>调用构造函数 将构造函数中的<span class="token keyword">this</span> 都吸引到<span class="token keyword">new</span>上<span class="token operator">!</span>
              然后通过强行赋 
      问题：构造函数虽然实现了代码重用<span class="token punctuation">,</span>但是浪费了内存！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h2> <h3 id="什么是-7"><a href="#什么是-7" class="header-anchor">#</a> 什么是:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code> 爹的成员 孩子无需重复创建<span class="token punctuation">,</span>可直接使用
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="为什么-5"><a href="#为什么-5" class="header-anchor">#</a> 为什么:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code> 代码重用<span class="token punctuation">,</span> 节约内存
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="何时-6"><a href="#何时-6" class="header-anchor">#</a> 何时：</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    只要多个孩子都需要共用的成员<span class="token punctuation">,</span>都通过继承使用！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="如何-4"><a href="#如何-4" class="header-anchor">#</a> 如何：</h3> <p>​      不用自己设置继承关系！其实js中已经帮我们设置好了继承关系  我们直接使用即可！</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token number">1.</span> js实现继承<span class="token punctuation">,</span> 都是通过继承原型对象来实现的
              
		原型对象：专门集中保存一类对象的共有成员的父对象。

        原型对象是在定义构造函数时<span class="token punctuation">,</span>附赠的。只不过暂时是空的
        如何找到原型对象<span class="token operator">:</span> 每个构造函数都有一个prototype 指向自己附赠的这个原型对象
        其实 原型对象中 也有一个constructor属性 指回构造函数

子对象如何继承父对象<span class="token operator">:</span>
              
		<span class="token keyword">new</span> 的 第<span class="token number">2</span>步：让子对象的__proto__属性指向妈妈的原型对象 凡是从__proto__属性值指出的关系<span class="token punctuation">,</span>都叫继承关系。
        
        结果： 原型对象中的成员 子对象无需创建 可直接使用！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>如何向原型对象中添加共有成员:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    <span class="token class-name">妈妈</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>成员名<span class="token operator">=</span>值
    比如 向所有学生的共同的爸爸 里强行添加一个公用的方法 <span class="token function">intrSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">intrSelf</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token operator">...</span><span class="token punctuation">.</span> <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    结果： 凡是 Student 生的孩子 都能<span class="token punctuation">.</span><span class="token function">inerSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>来直接调用爹的函数
      比如  lilei<span class="token punctuation">.</span><span class="token function">intrSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    妈妈叫爸爸 prototype
    孩子叫爸爸  __proto__ 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​</p> <h2 id="自有属性-和-共有属性"><a href="#自有属性-和-共有属性" class="header-anchor">#</a> 自有属性 和 共有属性：</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>       自有属性：保存在子对象中 归对象个人所以有的属性

       共有属性：保存在原型对象中<span class="token punctuation">,</span>归于多个子对象共有的属性
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>获取属性值： 二者没有任何差别  子对象.属性名</p> <p>修改属性值:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>自有属性<span class="token punctuation">,</span>可直接用子对象修改
比如 lilei<span class="token punctuation">.</span>sage<span class="token operator">++</span><span class="token punctuation">;</span>

共有属性<span class="token punctuation">,</span>只能用原型对象修改
如果强行用子对象<span class="token punctuation">.</span>共有属性修改 
会给这个子对象添加一个同名的自有属性。 从此这个子对象和父对象的属性无关了
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="内置对象的原型对象"><a href="#内置对象的原型对象" class="header-anchor">#</a> 内置对象的原型对象:</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>任何一种类型 其实都是由构造函数和原型对象组成。内置类型也是这样。
Js包括的那些内置类型：
        String Number Boolean
        Array  Date  Math RegExp  Error  Function  Object 
        global  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​</p> <h2 id="所有内置类型也包含构造函数和原型对象"><a href="#所有内置类型也包含构造函数和原型对象" class="header-anchor">#</a> 所有内置类型也包含构造函数和原型对象：</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>构造函数<span class="token operator">:</span> 创建该类型的子对象
原型对象：保存该类型的所有子对象共有的方法和属性
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>比如: Array 类型就包含2部分</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span><span class="token function-variable function">数组类型构造函数</span><span class="token operator">:</span>
        <span class="token keyword">function</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
        所以创建数组可以使用<span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">2</span> 数组类型也有一个原型对象 包含所有数组对象公用的函数<span class="token operator">:</span>
        为一个类型添加一个共有的自定义函数<span class="token punctuation">;</span>
        何时<span class="token operator">:</span> 只要项目中 经常对一个类型的对象做一种操作 而这个类型的原型对象中又不包含这种函数。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如何: 比如:为所有数组添加求和这种函数</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span> 在数组类型的原型对象中添加sum函数
<span class="token number">2</span> 用数组类型的子对象 调用这个sum
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="面向对象-2"><a href="#面向对象-2" class="header-anchor">#</a> 面向对象</h2> <h3 id="继承-2"><a href="#继承-2" class="header-anchor">#</a> 继承:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  原型链
        
    什么是<span class="token operator">:</span> 由多级父对象 逐级继承 形成链式结果
        作用：
         
          <span class="token number">1.</span> 保存了一个对象可用的所有成员 
             将来判断一个对象可以使用那些成员<span class="token punctuation">,</span>就看它的原型链
             上有什么成员
            
             如果一个成员在子对象的原型链的某个父级对象上 就可以<span class="token operator">:</span>子对象<span class="token punctuation">.</span>成员  访问
            
             如果一个成员不包含在子对象的原型链的任意一个对象上<span class="token punctuation">,</span>就不能用 子对象<span class="token punctuation">.</span>成员访问
          
          <span class="token number">2.</span> 控制着成员的使用顺序<span class="token operator">:</span>
              先自有 再共有！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h2> <h3 id="什么是-8"><a href="#什么是-8" class="header-anchor">#</a> 什么是:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  一个函数<span class="token punctuation">,</span>在不同情况下表现出不同的状态
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="包括"><a href="#包括" class="header-anchor">#</a> 包括:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    <span class="token number">1.</span>  重载<span class="token operator">:</span> 根据传入参数的
    <span class="token number">2.</span>  重写<span class="token operator">:</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="什么是-9"><a href="#什么是-9" class="header-anchor">#</a> 什么是:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code> 在子对象中定义和父对象中成员完全相同的成员 来覆盖父对象的成员     
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="为什么-6"><a href="#为什么-6" class="header-anchor">#</a> 为什么:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code> 从爹继承来的成员不一定都是好用的！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="何时-7"><a href="#何时-7" class="header-anchor">#</a> 何时：</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>只要子对象觉得从爹继承来的不好用就要重写！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="如何-5"><a href="#如何-5" class="header-anchor">#</a> 如何：</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>只要在子对象中定义和父对象同名的成员
​    
console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//输出对象的存储结构</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="自定义继承"><a href="#自定义继承" class="header-anchor">#</a> 自定义继承:</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    何时<span class="token operator">:</span> 只要觉得现在的爹不好用！就可以用
    如何<span class="token operator">:</span>
        
        <span class="token number">1.</span> 只更换一个对象的爹
            
            子对象__proto__<span class="token operator">=</span>新爹
            
            问题<span class="token operator">:</span>__proto__浏览器不推介使用
            
            解决<span class="token operator">:</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>代替__prpto__ 
            Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>子元素<span class="token punctuation">,</span>新爹<span class="token punctuation">)</span>
     
  <span class="token keyword">set</span>        <span class="token keyword">of</span> Prototype
  
  设置子元素  的 原型对象 为 新爹
  Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>hmm<span class="token punctuation">,</span>father<span class="token punctuation">)</span><span class="token punctuation">;</span>
     
        <span class="token number">2.</span> 同时多个对象的爹
            <span class="token class-name">构造函数</span><span class="token punctuation">.</span>prototype<span class="token operator">=</span>新老公
            时机<span class="token operator">:</span> 在创建子对象之前换
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h1 id="es5"><a href="#es5" class="header-anchor">#</a> ES5</h1> <h2 id="什么是-10"><a href="#什么是-10" class="header-anchor">#</a> 什么是:</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>EMAScript 标准的第五个升级版本
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="为什么-7"><a href="#为什么-7" class="header-anchor">#</a> 为什么:</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code> 因为Js这门语言 又很多广受诟病的缺陷
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>包括哪些新的规则:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token string">&quot;use strict&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>严格模式:</p> <p>什么是:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  比普通Js运行要求更严格的机制
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>为什么:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  因为Js这门语言 又很多广受诟病的缺陷
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>何时：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  今后所有Js程序都要在严格模式下！
          
          严格模式的新需求<span class="token operator">:</span> 
          
          <span class="token number">1.</span> 禁止给未声明变量赋值！
                旧Js 强行给未声明的变量赋值 
            结果<span class="token operator">:</span> 会自动在全局创建
                  全局污染 内存泄漏
          
            严格Js中 强行给未声明的变量赋值
            结果<span class="token operator">:</span> 报错<span class="token operator">:</span>xxx is not <span class="token keyword">undefined</span><span class="token operator">!</span>
            避免内存泄漏和全局污染

         <span class="token number">2.</span> 静默失败升级为错误
               静默失败<span class="token operator">:</span>执行不成功 也不报错！
                   极其不便调试
             严格模式中<span class="token operator">:</span>静默失败 也会报错！    便于调试
         
         <span class="token number">3.</span> 普通函数调用和匿名函数自调中的<span class="token keyword">this</span>不再默认指向window 而是指向<span class="token keyword">undefined</span>
         防止全局污染 内存泄漏  

         <span class="token number">4.</span> 禁止使用 arguments<span class="token punctuation">.</span>callee
              
            什么是 arguments<span class="token punctuation">.</span>callee<span class="token operator">:</span> 是函数运行时<span class="token punctuation">,</span> 专门获得当前正在执行的函数本身。
          
            何时<span class="token operator">:</span> 递归！        
              为什么<span class="token operator">:</span>避免紧耦合 避免在函数内写死函数名。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>​<br>
​</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    问题<span class="token operator">:</span> 递归效率极低！———— 重复计算量太大
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​<br>
​</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    所以 Es5 严格模式 出于性能考虑 禁用了 arguments<span class="token punctuation">.</span>callee 就暗示不推介使用递归算法。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​<br>
​</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    解决：绝大多数的递归可以找循环代替

    为什么<span class="token operator">:</span>避免紧耦合 避免在函数内写死函数名。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​<br>
​</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    问题<span class="token operator">:</span> 递归效率极低！———— 重复计算量太大

    所以 Es5 严格模式 出于性能考虑 禁用了 arguments<span class="token punctuation">.</span>callee 就暗示不推介使用递归算法。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    解决：绝大多数的递归可以找循环代替
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="保护对象"><a href="#保护对象" class="header-anchor">#</a> 保护对象:</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    什么是<span class="token operator">:</span>
        
        控制对象的属性值或对象结构进行的随意篡改
    
    为什么<span class="token operator">:</span> 
    
        在旧的Js中 对象的属性和结构毫无自保能力。 任何人可在任何时候修改属性值为任何值 也可以随意添加属性和删除属性
   
     何时<span class="token operator">:</span> 
     
     	需要控制对对象的访问时

  如何：<span class="token number">2</span>个层面<span class="token operator">:</span>        
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="language- extra-class"><pre><code>    ###  保护对象的属性
</code></pre></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">ES5</span>对对象的属性进行了重新分类
        命名属性<span class="token operator">:</span> 可用<span class="token punctuation">.</span>访问到属性
            又分为<span class="token operator">:</span>
                数据属性 实际存储属性值的属性。
       
                访问器属性 不实际存储属性值<span class="token punctuation">,</span>仅提供对另一个数据属性的保护。
                
        内部属性： 无法用<span class="token punctuation">.</span>访问到内部的属性
        
        如何保护数据属性：
            旧js中 数据属性其实就是一个普通的变量 毫无自保能力
        
            <span class="token constant">ES5</span> 标准中<span class="token operator">:</span> 每个数据属性都是一个缩微的小对象。 每个小对象中<span class="token punctuation">,</span>保存一个属性和三个开关

            如何修改属性的小开关来保护一个属性呢
        
            问题<span class="token operator">:</span> 不能用<span class="token punctuation">.</span>直接修改属性对象内部的开关属性！

      解决：必须用专用的函数解决
    
            Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>
                对象名<span class="token punctuation">,</span>
                <span class="token string">&quot;属性名&quot;</span><span class="token punctuation">,</span>
                <span class="token punctuation">{</span>
                  开关：<span class="token boolean">true</span><span class="token operator">/</span><span class="token boolean">false</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>问题:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>writable和enumerable两个开关<span class="token punctuation">,</span>任何人都可以随意开关。所以设置这两个起不到保护作用。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>解决:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>只要设置 writeble 和 enumerable
都要同时关闭configurable<span class="token punctuation">,</span> 目的是禁止修改前两个开关
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>解决:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>只要设置writable 和 enumerable 都要同时关闭configurable 目的是禁止修改两个开关。 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="configurable一旦被改为fals-不可逆"><a href="#configurable一旦被改为fals-不可逆" class="header-anchor">#</a> configurable一旦被改为fals 不可逆！</h3> <p>问题:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code> enumerable 只能禁止<span class="token keyword">for</span> <span class="token keyword">in</span> 遍历这个属性 无法阻止用<span class="token punctuation">.</span>直接访问这个属性。———— 这是半隐藏 
 
  解决： 无法解决
  问题： Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>一次只能修改对象中的一个属性。如果外部修改多个属性 就要重复写多遍
  
  解决<span class="token operator">:</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>
      对象名<span class="token punctuation">,</span><span class="token punctuation">{</span>
        属性名<span class="token operator">:</span><span class="token punctuation">{</span>
          开关：<span class="token boolean">true</span><span class="token operator">/</span><span class="token boolean">false</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">.</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>

问题<span class="token operator">:</span> 使用保护属性 规则单调 无法使用自定规则保护属性
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>解决:使用访问器属性保护数据属性</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>什么是访问器属性 自己不保存数据<span class="token punctuation">,</span>专门提供对其他数据属性的保护。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>何时：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>只要使用灵活的自定义规则保护数据时 就会要请保镖！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如何:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>      <span class="token number">0.</span> 先将要保护的数据属性  隐形埋名<span class="token punctuation">,</span> 并且半隐藏！！
      <span class="token number">1.</span> 为对象添加访问器属性<span class="token punctuation">,</span>保护属性
         
          <span class="token number">1</span> 访问器属性要冒名顶替使用原属性名
          <span class="token number">2</span> 访问器属性中包含<span class="token keyword">get</span> <span class="token keyword">set</span>两个属性值
          
          <span class="token keyword">get</span> 负责读取受保护的属性值
          <span class="token keyword">set</span> 中负责先验证再修改受保护的属性值
          
          访问器属性不再需要value和writable。 但是需要设置enumerable 和 configurable
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>访问器属性如何发挥作用:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>因为访问器属性是冒名顶替的所以<span class="token punctuation">,</span>外人访问器属性时 和 访问普通属性是一样的

只不过访问器属性执行时<span class="token punctuation">,</span> 会自动根据外人做到的操作<span class="token punctuation">,</span>来选择<span class="token keyword">get</span>和<span class="token keyword">set</span> 来调用 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="保护对象-2"><a href="#保护对象-2" class="header-anchor">#</a> 保护对象</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>保护对象的属性<span class="token operator">:</span>

保护对象的结构<span class="token operator">:</span> <span class="token number">3</span> 个级别
      <span class="token number">1.</span> 禁止添加新属性<span class="token operator">:</span>
                Object<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
      
            阻止对obj对象添加任何扩展属性 
            原理 每个对象都有一个隐藏的
            
            extensible的属性默认值为<span class="token boolean">true</span>
            <span class="token function">preventExtensions</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>使这个内部隐藏属性改为<span class="token boolean">false</span>
      
      <span class="token number">2.</span> 密封：在兼具防扩展的基础上 进一步禁止删除现有属性
          Object<span class="token punctuation">.</span><span class="token function">seal</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>​2 件事</p> <ol><li>禁止添加新属性</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Object的extensible <span class="token operator">=</span> <span class="token boolean">false</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="2"><li>禁止删除现有属性</li> <li>有属性的configurable 都改为false！ 从此defineProperties中不需要再重复写 configirable:false!</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code>其实今后 大多数对象都要密封！ 
强调： 虽然密封禁止修改结构 但是属性值随便改！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>冻结： 在兼具密封的基础上 进一步禁止删除现有属性 禁止修改属性值！</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">freesze</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>3 件事:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 禁止添加新属性 
    
	obj的extensidle<span class="token operator">=</span><span class="token boolean">false</span>

<span class="token number">2.</span> 禁止删除现有属性<span class="token operator">:</span>

    自动 将所有的属性的configurable都改为<span class="token boolean">false</span>！

<span class="token number">3.</span> 自动将所有属性的writable都改为<span class="token boolean">false</span>。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="object-create"><a href="#object-create" class="header-anchor">#</a> Object.create()</h3> <p>函数:没有构造函数的情况下，也想到创建一个子对象    子对象继承的简单写法</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">3</span> 件事<span class="token operator">:</span>  
        <span class="token number">1.</span>创建一个新对象
        <span class="token number">2.</span> 继承一个父对象
        <span class="token number">3.</span> 为新对象添加自有属性

        <span class="token keyword">var</span> 子对象 <span class="token operator">=</span>  Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>父对象<span class="token punctuation">,</span><span class="token punctuation">{</span>
                <span class="token comment">// defineProperties</span>
                属性名<span class="token operator">:</span><span class="token punctuation">{</span>
                  value <span class="token operator">:</span> 属性值<span class="token punctuation">,</span>
                  writable<span class="token operator">:</span><span class="token boolean">true</span><span class="token operator">/</span><span class="token boolean">false</span><span class="token punctuation">,</span>
                  enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token operator">/</span><span class="token boolean">false</span><span class="token punctuation">,</span>
                  configurable <span class="token operator">:</span> <span class="token boolean">true</span><span class="token operator">/</span><span class="token boolean">false</span>	
                <span class="token punctuation">}</span>
                <span class="token operator">...</span><span class="token operator">...</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="call-apply-bind-替换this"><a href="#call-apply-bind-替换this" class="header-anchor">#</a> call,apply,bind: 替换this</h2> <h3 id="何时-8"><a href="#何时-8" class="header-anchor">#</a> 何时:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  只要函数执行时 内部<span class="token keyword">this</span> 不是我们想要的
  就可以使用这三个函数 将不想要的<span class="token keyword">this</span>换成任意一个想要的对象。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="如何-6"><a href="#如何-6" class="header-anchor">#</a> 如何：</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token number">1.</span> call<span class="token punctuation">,</span>apply<span class="token operator">:</span> 在一次调用函数时，临时替换一次<span class="token keyword">this</span>！
        <span class="token function">要调用的函数</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>替换<span class="token keyword">this</span>的对象，<span class="token operator">...</span><span class="token punctuation">)</span>
        强调<span class="token operator">:</span> 实参值列表必须从第二个值开始。
        因为第一个实参的位置让给了替换<span class="token keyword">this</span>的对象！
  原理<span class="token operator">:</span> 
        call 更大的作用：可让任何对象去调用原本没有任何关系的一个函数。 —————— 抢
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="apply-vs-call"><a href="#apply-vs-call" class="header-anchor">#</a> apply vs call:</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>apply 和 call 用法几乎完全一样。只不过<span class="token punctuation">,</span>要求所有的实参值都要放在一个数组中整体传入。

执行过程：
    <span class="token number">1.</span> 先用第一个参数值对象替换函数中的不想要的<span class="token keyword">this</span>。
    <span class="token number">2.</span> 打散数组为多个单独的元素值，分别传给对应的每个形参变量

总结：通常情况下 要替换函数中的<span class="token keyword">this</span><span class="token punctuation">,</span>用call就够了！ 只有实参值类表是放在一个数组中的时候才需要使用apply 先打散再传入函数。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="bind"><a href="#bind" class="header-anchor">#</a> bind</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>bind<span class="token operator">:</span> 不调用函数<span class="token punctuation">,</span>而是基于函数<span class="token punctuation">,</span>创建一个新函数副本。并永久替换新函数中的<span class="token keyword">this</span>为指定的对象。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="何时-9"><a href="#何时-9" class="header-anchor">#</a> 何时:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>今后<span class="token punctuation">,</span>如果一个函数需要反复调用，又反复替换其中的<span class="token keyword">this</span>时 都是用 <span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 来创建副本<span class="token punctuation">,</span>
并永久绑定<span class="token keyword">this</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="如何-7"><a href="#如何-7" class="header-anchor">#</a> 如何:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> 新函数 <span class="token operator">=</span> <span class="token function">旧函数</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>
    替换<span class="token keyword">this</span>的对象<span class="token punctuation">,</span>
    要绑定的实参值<span class="token punctuation">,</span>
    <span class="token operator">...</span><span class="token punctuation">.</span>                                  
<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>结果:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 新函数的功能和就函数是完全一样的。
<span class="token number">2.</span> 但是新函数中的<span class="token keyword">this</span>和开头部分形参<span class="token punctuation">,</span>已被永久替换为固定的对象和固定的参数值。
<span class="token number">3.</span> 今后调用新函数时<span class="token punctuation">,</span>只要传入可能变化的剩余几个实参值即可！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="数组函数"><a href="#数组函数" class="header-anchor">#</a> 数组函数</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>数组中查找元素<span class="token operator">:</span> indexOf 
  
  数组中的indexOf 和字符串的 indexOf 完全一样
  <span class="token keyword">var</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;元素&quot;</span><span class="token punctuation">,</span>fromi<span class="token punctuation">)</span><span class="token punctuation">;</span>
  在arr数组中 从 fromi位置开始 找下一个和指定<span class="token string">&quot;元素&quot;</span>相同的元素所在的位置i
      返回值<span class="token operator">:</span>如果找到 返回 i
              如果没有找到 返回<span class="token operator">-</span><span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="判断"><a href="#判断" class="header-anchor">#</a> 判断:</h3> <ol><li>判断数组中是否所有元素都符合要求</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code>      <span class="token keyword">var</span> bool <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>i<span class="token punctuation">,</span>arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//value 当前元素值</span>
        <span class="token comment">// i 当前索引位置</span>
        <span class="token comment">// arr 当前数组元素</span>
        <span class="token keyword">return</span> 判断条件<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
          
原理 every 会自动遍历arr中的每个元素。
  
每遍历一个元素<span class="token punctuation">,</span>就会自动调用一次回调函数<span class="token keyword">function</span>。

每次调用<span class="token keyword">function</span>时<span class="token punctuation">,</span>自动传入当前正在遍历的元素值和下标位置<span class="token punctuation">,</span>以及当前数组对象<span class="token punctuation">,</span>每次调<span class="token keyword">function</span> 都会用函数内的条件检查当前元素会否符合要求 

只有当前元素符合要求 才能继续遍历下一个元素。 只要碰一个不符合要求的元素<span class="token punctuation">,</span>就立刻退出遍历 返回<span class="token boolean">false</span>。意思是不是所有元素都满足要求。
如果遍历结束<span class="token punctuation">,</span>还没有退出<span class="token punctuation">,</span>说明整个数组中都符合要求 <span class="token function">整个every</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>就返回<span class="token boolean">true</span>
arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ol start="2"><li>判断数组中是否包含符合要求的元素</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> bool <span class="token operator">=</span>arr<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>i<span class="token punctuation">,</span>arr</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> 判断条件
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>用法和every完全相同 只不过执行时 只要碰到一个元素判断为true  就不不再遍历,直接返回true。</p> <p>只有遍历结束 还没有找到判断为true才返回false;</p> <p>​</p> <h2 id="遍历"><a href="#遍历" class="header-anchor">#</a> 遍历</h2> <h3 id="普通遍历-代替for循环"><a href="#普通遍历-代替for循环" class="header-anchor">#</a> 普通遍历: 代替for循环</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//i  当前位置 // arr[i] 当前元素值 </span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>i<span class="token punctuation">,</span>arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//对当前元素执行的操作！</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>forEach中自动遍历arr中的每个元素 每遍历一个元素 就在这个元素上自动调用一次回调函数<span class="token keyword">function</span> 自动传入当前元素值给value 当前位置给i 当前数组对象给arr。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="遍历并复制原数组为新数组"><a href="#遍历并复制原数组为新数组" class="header-anchor">#</a> 遍历并复制原数组为新数组</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> 新数组<span class="token operator">=</span>原数组<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>
    <span class="token comment">// var newArr=[];//自动</span>
    <span class="token comment">// for(var i=0; i&lt;arr.length;i++){}</span>
    <span class="token comment">//      arr[i] i this</span>
    <span class="token comment">//          ↓  ↓  ↓</span>
    <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>i<span class="token punctuation">,</span>arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> 要放入的新数组中的元素值
    <span class="token punctuation">}</span>
    <span class="token comment">//return newArr;//自动</span>
<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="原理"><a href="#原理" class="header-anchor">#</a> 原理:</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> map 内先自动创建一个新数组

<span class="token number">2.</span> 然后才是带着回调函数一起遍历 原数组<span class="token punctuation">.</span>自动将回调函数在每个元素上执行一次 将回调函数<span class="token keyword">return</span>的结果 放到新的数组中相同的位置上

<span class="token number">3.</span> 遍历结束 返回新数组
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 仅单纯代替 <span class="token keyword">for</span> 循环遍历数组<span class="token punctuation">,</span>首选foreach
<span class="token number">2.</span> 除非想保护原数组<span class="token punctuation">,</span>返回的新数组时 采用map<span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="过滤和汇总"><a href="#过滤和汇总" class="header-anchor">#</a> 过滤和汇总：</h3> <p>过滤: 复制出原数组中符合条件的元素组成 新数组返回. 原数组保持不变！</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> 新数组<span class="token operator">=</span>原数组<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>
    <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>i<span class="token punctuation">,</span>arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> 判断条件
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>原理:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>先创建一个空数组

<span class="token number">2.</span>自动遍历原数组中每个元素 每遍历一个元素 就自动调用一次回调函数 如果当前元素经过回调函数验证<span class="token punctuation">,</span>返回<span class="token boolean">true</span> 则加入新数组中 如果当前元素经过回调函数验证 返回<span class="token boolean">false</span> 则不加入新数组<span class="token punctuation">.</span> 

<span class="token number">3.</span> 遍历结束<span class="token punctuation">,</span>返回新数组！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="2"><li>汇总： 对数组中的元素内同容进行统计 得出最终结论</li></ol> <p>作业</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span> 如何用<span class="token constant">ES5</span>实现两种类型的继承 ———— 手写
<span class="token number">2</span> 如何 判断一个对象是不是数组 共有几种方法！ <span class="token number">6</span>种以上
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h1 id="es6"><a href="#es6" class="header-anchor">#</a> ES6</h1> <h2 id="什么是-ecmascript-第6个版本"><a href="#什么是-ecmascript-第6个版本" class="header-anchor">#</a> 什么是:ECMAScript 第6个版本</h2> <p>优点: 在不改变原理的基础上 简化了Js代码</p> <p>问题: 兼容性</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  包括<span class="token operator">:</span>

      <span class="token keyword">let</span><span class="token operator">:</span>
          什么是<span class="token operator">:</span>  专门代替<span class="token keyword">var</span> 来声明变量用
         
          为什么<span class="token operator">:</span>  <span class="token keyword">var</span> 的问题<span class="token operator">:</span>
              <span class="token number">1.</span> 声明提前
              <span class="token number">2.</span> 没有块级作用域
         
          何时<span class="token operator">:</span> 只要声明变量都用 <span class="token keyword">let</span>
         
              优点：
                  <span class="token number">1.</span>阻止了声明提前
                  <span class="token number">1.</span> 添加块级作用域
         
          原理<span class="token operator">:</span> <span class="token keyword">let</span> 其实就是一个匿名自调<span class="token operator">!</span>
                且<span class="token keyword">let</span> 为了双保险 其实底层悄悄给变量改了名字
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>​              let 小脾气
​                  1 在相同作用域/块内，禁止同时let两个同名的变量
​<br>
​                  2 在let a之前到当前作用域顶不允许提前使用 a 变量</p> <h2 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数:</h2> <p>什么是  对普通函数声明的简写</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>何时： 今后绝大多数匿名函数的创建 都用箭头函数。

如何 <span class="token number">3</span>件事

    <span class="token number">1</span> 去掉 <span class="token keyword">function</span> <span class="token function">在</span><span class="token punctuation">(</span><span class="token punctuation">)</span>和<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token parameter">之间</span><span class="token operator">=&gt;</span>

    <span class="token number">2</span> 如果形参列表只有一个变量 <span class="token function">可省略</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token number">3</span> 如果函数体只有一句话 可省略<span class="token punctuation">{</span><span class="token punctuation">}</span>
    但是 如果仅有的这句话 还是<span class="token keyword">return</span> 则必须省略<span class="token keyword">return</span>
    去掉<span class="token punctuation">{</span><span class="token punctuation">}</span>时 还要注意去掉语句结尾<span class="token string">&quot;;&quot;</span>

双刃剑

让函数内外<span class="token keyword">this</span>连通 保持一致。都指向函数外<span class="token keyword">this</span>

结论<span class="token operator">:</span> 如果希望函数内的<span class="token keyword">this</span>和函数外的<span class="token keyword">this</span> 不一致时！ 就不能用箭头函数！

比如： 对象的方法不能用箭头函数简写

比如： <span class="token constant">DOM</span>中的事件处理函数也不能用箭头函数简写
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>问题  一旦改为箭头函数则不能使用arguments</p> <h2 id="for-of"><a href="#for-of" class="header-anchor">#</a> For of</h2> <p>什么是 在特定情况下专门简化for循环</p> <p>总结:  遍历一个数组：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>优点: 即可控制遍历的方向 有可遍历循环的步调</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">2.</span>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">elem<span class="token punctuation">,</span>i<span class="token punctuation">,</span>arr</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token comment">//当前元素 elem</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>局限: 不能控制遍历的方向 也不能控制便利的步调</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">3.</span> <span class="token keyword">for</span> <span class="token keyword">of</span>
如何<span class="token operator">:</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> elem <span class="token keyword">of</span> 数组<span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token comment">//of 会依次取出数组每个元素值，保存在of前的变量elem中</span>

<span class="token punctuation">}</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>局限: 只能获得元素值 无法获得当前元素位置
​<br>
其实 for of 不但可以用于数组 还可以用于字符串,类数组对象,单个数值</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>总结<span class="token operator">:</span> <span class="token keyword">for</span> <span class="token keyword">of</span> 可以遍历数字下标数组<span class="token punctuation">,</span> 类数组对象<span class="token punctuation">,</span>字符串 中的每个字。

<span class="token keyword">for</span> <span class="token keyword">in</span> 专门遍历自定义下标的关联数组 和对象。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="参数增强"><a href="#参数增强" class="header-anchor">#</a> 参数增强</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    什么是<span class="token operator">:</span><span class="token constant">ES6</span>中对函数的参数 提供了更强大<span class="token punctuation">,</span>更方便的功能
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>包括:</p> <ol><li><p>参数默认值(default);</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">函数名</span><span class="token punctuation">(</span><span class="token parameter">形参<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>形参n<span class="token operator">=</span>默认值</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    如果没有传入最后一个参数 则使用默认值作为备胎 
  <span class="token punctuation">}</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language- extra-class"><pre><code> ES5 的代替方式:形参 n=形参n||默认值
</code></pre></div><div class="language-js line-numbers-mode"><pre class="language-js"><code></code></pre> <div class="line-numbers-wrapper"></div></div></li></ol> <p>如果形参n是有意义的值不是false&quot;&quot;,undefined,null,NaN 就用 形参n 的值继续向后执行</p> <div class="language- extra-class"><pre><code> // 如果 形参n是没有意义的值 就用默认值作为备胎
 
 强调: 局限 只能解决最后一个形参不确定的情况。
 ````
</code></pre></div><ol start="2"><li><p>剩余参数(rest);</p> <div class="language- extra-class"><pre><code> 什么是:专门代替arguments
 为什么:arguments的问题
</code></pre></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 不是纯正的数组类型 用不了数组家的函数

<span class="token number">2.</span> 不支持箭头函数
何时<span class="token operator">:</span> 今后只要使用arguments的地方都可以使用rest语法代替

如何<span class="token operator">:</span>
    定义函数时：
      <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">形参<span class="token number">1</span><span class="token punctuation">,</span>形参<span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">...</span>数组名</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

        <span class="token comment">//...后的数组会接住除之前形参外的其他所有剩余实参值</span>
        
        <span class="token comment">// 数组是纯正的数组类型可随意使用数组家的函数</span>
        <span class="token comment">//即使fun改为箭头函数 依然可以使用...数组名的rest语法 </span>
      <span class="token punctuation">}</span> <span class="token function">打散数组</span><span class="token punctuation">(</span>spead<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></li></ol> <h3 id="为什么-8"><a href="#为什么-8" class="header-anchor">#</a> 为什么:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    代替apply 
    apply的问题是 本职工作不是打散数组，而是替换<span class="token keyword">this</span> 顺便打散数组。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="何时-10"><a href="#何时-10" class="header-anchor">#</a> 何时:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    今后只要希望将一个数组整体 打散为单个值
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="如何-传递参数或赋值时"><a href="#如何-传递参数或赋值时" class="header-anchor">#</a> 如何： 传递参数或赋值时</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span>arr<span class="token punctuation">)</span>
    先将arr中的元素值打散为单个值 <span class="token function">再分别传给fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>项目中:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token number">1.</span> 拼接两个数组
      <span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>arr2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr1<span class="token punctuation">,</span>arr2<span class="token punctuation">]</span><span class="token punctuation">;</span>
      arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
  <span class="token number">2.</span> 合并两个对象
      <span class="token keyword">var</span> obj1<span class="token operator">=</span><span class="token punctuation">{</span>x<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>obj2<span class="token operator">=</span><span class="token punctuation">{</span>b<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span>  obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>obj1<span class="token punctuation">,</span><span class="token operator">...</span>obj2<span class="token punctuation">}</span>
      obj<span class="token operator">:</span><span class="token punctuation">{</span>x<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="解构"><a href="#解构" class="header-anchor">#</a> 解构:</h2> <h3 id="什么是-11"><a href="#什么是-11" class="header-anchor">#</a> 什么是:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  将一个大的对象或数组中的个别成员 提取出来<span class="token punctuation">,</span>单独使用
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="何时-11"><a href="#何时-11" class="header-anchor">#</a> 何时:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  如果给的是一个巨大的对象<span class="token punctuation">,</span>而我们这个功能，
 只需要其中个别函数或者属性时 就要将所需的成员解构 出来 单独使用。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="如何-8"><a href="#如何-8" class="header-anchor">#</a> 如何：</h3> <p>数组解构：</p> <p>什么是: 将大的数组中的个别元素提取出来单独使用。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>如何<span class="token operator">:</span>下标对下标
<span class="token punctuation">[</span>变量<span class="token number">1</span><span class="token punctuation">,</span>变量<span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token operator">=</span>数组
 <span class="token number">0</span>     <span class="token number">1</span>  <span class="token operator">...</span> 
 结果<span class="token operator">:</span> 变量<span class="token number">1</span> <span class="token operator">=</span> 数组<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
变量<span class="token number">2</span> <span class="token operator">=</span> 数组<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>对象解构</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code> 什么是<span class="token operator">:</span> 将大的数组中的个别元素提取出来单独使用
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如何：  属性名对属性名</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>属性名<span class="token number">1</span><span class="token operator">:</span>变量<span class="token number">1</span><span class="token punctuation">,</span>属性名 <span class="token number">2</span><span class="token operator">:</span> 变量<span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token operator">=</span>对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>结果<span class="token operator">:</span> 变量<span class="token number">1</span><span class="token operator">=</span>对象<span class="token punctuation">.</span>属性名 <span class="token number">1</span>

变量<span class="token number">2</span> <span class="token operator">=</span> 对象<span class="token punctuation">.</span>属性名<span class="token number">2</span>

简写 如果新变量的名字延用成员对象中的属性名<span class="token punctuation">,</span>则可以简写 

比如<span class="token operator">:</span>user 对象中 解构出登录方法和注册方法单独使用

<span class="token keyword">var</span> <span class="token punctuation">{</span>signin<span class="token operator">:</span>signin<span class="token punctuation">,</span>signup<span class="token operator">:</span>signup<span class="token punctuation">}</span><span class="token operator">=</span>user
可简写<span class="token operator">:</span>
<span class="token keyword">var</span> <span class="token punctuation">{</span>signin<span class="token punctuation">,</span>signup<span class="token punctuation">}</span> <span class="token operator">=</span>user<span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="参数结构"><a href="#参数结构" class="header-anchor">#</a> 参数结构</h2> <h3 id="什么是-12"><a href="#什么是-12" class="header-anchor">#</a> 什么是</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    在定义函数和调用函数时采用对象结构传递参数。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="何时-12"><a href="#何时-12" class="header-anchor">#</a> 何时:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    多个形参值不确定有没有 而且有要求实参值与形参值之间必须对应。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="为什么-9"><a href="#为什么-9" class="header-anchor">#</a> 为什么:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    默认值<span class="token operator">:</span> 局限<span class="token punctuation">;</span>只有最后一个形参不确定时 才能使用默认值
    <span class="token operator">...</span>rest 和 arguments；局限<span class="token punctuation">;</span> 无法让形参值与实参值一一对应。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>用对象结构传参:</p> <h3 id="问题-3"><a href="#问题-3" class="header-anchor">#</a> 问题:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    定义函数时只有一个对象形参 将来调用者不知道具体形参个数和名称！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如何：2步</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    <span class="token number">1</span> 定义函数时 形参写成对象语法！
    
    <span class="token number">2</span> 调用函数时 所有实参必须放在一个形参对象结构相同的对象中传入
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="面向对象上的简化"><a href="#面向对象上的简化" class="header-anchor">#</a> 面向对象上的简化：</h2> <h3 id="对单个对象提供了2处简化"><a href="#对单个对象提供了2处简化" class="header-anchor">#</a> 对单个对象提供了2处简化</h3> <div class="language- extra-class"><pre><code>  如果对象的属性提供了2处简化
  
        1. 如果对象的属性值来自于对象外的变量,且变量名刚好和属性名相同 则不用写两遍相同的名字 只要写一遍即可。
  
        2. 所有对象的方法,不再需要写&quot;:function&quot;
            强调:对象的方法去掉:function 不等效于箭头函数 突出的特点 this保持不变！
            所以 去掉:function,只是单纯的简写 没有任何原理的改变！
</code></pre></div><p>​</p> <h3 id="class"><a href="#class" class="header-anchor">#</a> Class:</h3> <h4 id="什么是-13"><a href="#什么是-13" class="header-anchor">#</a> 什么是:</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    集中定义一种类型的所有对象统一属性结构和方法的程序结构。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="为什么-10"><a href="#为什么-10" class="header-anchor">#</a> 为什么</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    每一种类型 Array Student Date  都有两部分组成 构造函数<span class="token operator">+</span>原型对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="构造函数-2"><a href="#构造函数-2" class="header-anchor">#</a> 构造函数:</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>      负责定义 子对象统一的属性结构<span class="token punctuation">,</span>并且负责创建子对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="原型对象"><a href="#原型对象" class="header-anchor">#</a> 原型对象:</h5> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    负责保存所有子对象共有的属性值和方法
    但是<span class="token punctuation">,</span>在<span class="token constant">ES5</span>中 构造函数和原型对象是分开定义的。 不符合<span class="token string">&quot;封装&quot;</span>的要求
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="何时-13"><a href="#何时-13" class="header-anchor">#</a> 何时:</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    今后只要希望创建一种自定义类型时 都用<span class="token keyword">class</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="如何-3件事"><a href="#如何-3件事" class="header-anchor">#</a> 如何: 3件事</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token number">1.</span> 用<span class="token keyword">class</span><span class="token punctuation">{</span><span class="token punctuation">}</span>包裹 构造函数和原型对象方法
 
  <span class="token number">2.</span> 构造函数名提升为<span class="token keyword">class</span>名 所有构造函数<span class="token punctuation">,</span>从此统一更名为constructor
  
  <span class="token number">3.</span> 所有放在<span class="token keyword">class</span>中的函数<span class="token punctuation">,</span><span class="token class-name">不需要加类型名</span><span class="token punctuation">.</span>prototype前缀<span class="token punctuation">,</span>自动就保存在构造函数的原型对象中。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如何使用 class: 用法和从前的构造函数完全一样！
原型对象的原理依然保持不变。</p> <p>两种类型间的继承:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>问题： 两种类型之间包含部分相同的属性结构和方法定义。
解决： 定义一个上层的父类型<span class="token punctuation">,</span>集中保存两种子类型相同部分。
<span class="token keyword">extends</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="promise"><a href="#promise" class="header-anchor">#</a> Promise:</h2> <h3 id="什么是-14"><a href="#什么是-14" class="header-anchor">#</a> 什么是</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  专门保证多个异步函数 可以顺序执行的机制 而且还防止了回调地狱的问题
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="何时-14"><a href="#何时-14" class="header-anchor">#</a> 何时:</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    多个异步调用的函数  要求必须顺序执行！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="为什么-11"><a href="#为什么-11" class="header-anchor">#</a> 为什么：</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    其实用回调函数，也可以实现多个异步函数<span class="token punctuation">,</span>顺序执行 但是 使用回调函数
    会有回调地狱问题！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>问题1  多个异步函数要求顺序执行</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    错误的解决 仅按顺序调用
          结果 无法保证顺序执行
          因为 多个异步函数 相当于百米赛跑 每人之各占一条跑道 互相不会等待
  
    传统解决办法<span class="token operator">:</span>使用回调函数
              
              <span class="token number">1.</span> 在定义函数时 定义一个callback形参变量 
                  在函数内部 最后一句话执行之后自动调用callback（）
              
              <span class="token number">2.</span> 在调用函数h时<span class="token punctuation">,</span>传入一个函数 函数中包含
              下一步要执行的操作 ———— 提前托付
               效果   当前一个函数调用时 暂时不执行 传入的小函数
               只有前一个函数最后一句话执行完 才自动调用传入的小函数
               一次保证小函数一定会在异步函数调用完才执行  
               问题 当连续执行的异步函数非常多时就会形成回调地狱！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>解决:ES6 Promise</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    多个异步函数要求顺序执行
    
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>能接受下一个<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>取决于前一个<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>中的函数是否也支持Promise。如果前一个<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>中的函数支持Promise 则<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>可以继续<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>。
      
    如果前一个<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>中的函数不支持Promise 则不能继续<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>前后两个函数间传参:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>      <span class="token number">2</span>步<span class="token operator">:</span>
  
      <span class="token number">1.</span> 上一步函数中 <span class="token function">door</span><span class="token punctuation">(</span>参数值<span class="token punctuation">)</span>
  
      <span class="token number">2.</span> 下一个函数定义时就要定义一个形参准备接
         原理 当上一个函数调用 <span class="token function">door</span><span class="token punctuation">(</span>参数值<span class="token punctuation">)</span>时<span class="token punctuation">,</span>参数默认值 会顺着<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>交给<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>中的下一个函数的形参变量。
         在下一个中 就可通过自己的形参变量获得上一步传下来的参数值
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>局限：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">door</span><span class="token punctuation">(</span><span class="token punctuation">)</span>中只能传一个变量 如果必须穿多个值 则可以将多个值放在数组或对象中整体传入。  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>错误处理:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>如何<span class="token operator">:</span> 任何一个支持 Promise的函数中都有另一扇门 如果当前异步任务执行过程中发生错误就可以从另一扇门出来 一旦从报错这扇门出来后<span class="token punctuation">,</span>后续<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>都不再执行
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其实new Promise() 除了.then外 还有另一个方法.catch() 凡是从出错的门出来的代码都进入.catch()中执行错误处理操作</p> <p>等待多个异步任务完成才执行:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
    <span class="token function">多个支持Promise的函数调用</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token operator">...</span><span class="token punctuation">,</span>
    <span class="token operator">...</span><span class="token punctuation">,</span>  
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>后续操作<span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>问题：如果每个异步任务都返回一个接力棒 则如何获得所有接力棒呢？

解决：<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
其中 arr数组中保存了Promise<span class="token punctuation">.</span>all <span class="token function">中所有异步函数通过door</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回执行结果
强调<span class="token operator">:</span> arr中返回值存储的顺序和异步函数执行完成的顺序无关 只和调用的顺序有关！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​</p> <h3 id="一个promise有三个状态"><a href="#一个promise有三个状态" class="header-anchor">#</a> 一个Promise有三个状态</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> pending<span class="token operator">:</span>挂起 异步任务正在执行还没有执行完

<span class="token number">2.</span> resolve<span class="token operator">:</span>同意 当异步任务执行完<span class="token punctuation">,</span>且执行成功<span class="token punctuation">,</span>主动调用 <span class="token function">door</span><span class="token punctuation">(</span><span class="token punctuation">)</span>函数  会将Promise对象的状态 改为 resolve 当Promise对象状态改为resolve 就会自动执行<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>中的函数

<span class="token number">3.</span> reject<span class="token operator">:</span> 拒绝 当异步任务执行完 且执行失败 <span class="token function">主动调用err</span><span class="token punctuation">(</span><span class="token punctuation">)</span>函数  会将Promise对象的状态 改为reject  当Promise对象的状态 一旦被改为reject后 会自动调用  <span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>中的函数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​</p> <h3 id="promise的问题-并没有彻底消灭嵌套"><a href="#promise的问题-并没有彻底消灭嵌套" class="header-anchor">#</a> Promise的问题 并没有彻底消灭嵌套</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>比如 <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>weimin<span class="token punctuation">)</span> 
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;比赛结束&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    错误处理
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>解决:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ES7： async  awiat 可按照传统同步指定的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>代码一样 编写异步代码顺序执行
​<br>
只要多个异步任务需要顺序执行:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    同步代码<span class="token punctuation">;</span>
    <span class="token keyword">await</span> <span class="token function">异步函数</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    同步代码
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>其中 await 可让整段匿名函数自调暂时挂起 等待当前异步函数执行完 在执行后续代码！
​  强调：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>es7 的 <span class="token keyword">async</span> 和 <span class="token keyword">await</span> 仅仅简化的是Promise函数 调用的部分。而并没有简化 Promise 函数的定义 且 如果想用<span class="token keyword">await</span> 则异步函数
必须定义为支持Promise的样式
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>错误处理 如果<span class="token keyword">await</span>修饰的异步函数 <span class="token function">中调用了err</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法 打开了错误的门 则<span class="token keyword">await</span> 会认为是程序错误  

应该用 <span class="token keyword">try</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>来解决
强调<span class="token operator">:</span> 只有<span class="token keyword">async</span>下的<span class="token keyword">try</span> catch 才能捕获异步任务中的错误 没在<span class="token keyword">async</span>下的Js基础中所学的trycatch是不能捕获异步任务的！因为普通Js基础中的<span class="token keyword">try</span> catch 属于主程序 不会等待异步任务执行 就已经结束了 即使异步任务出错 <span class="token keyword">try</span> catch 因为早就结束了 所以根本捕获不到
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​      为什么 await 配合 try catch 就可以捕获异步任务中的错误呢？</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>      因为 <span class="token keyword">await</span> 可以留住当前程序中的一切代码 等待异步函数执行完。
​      <span class="token keyword">try</span> catch 就可能捕获到异步任务中的错误
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="kanbanniang" data-v-5775ee02><div class="banniang-container" style="display:;" data-v-5775ee02><div class="messageBox" style="right:68px;bottom:190px;display:none;" data-v-5775ee02>
      Kiven欢迎关注
    </div> <div class="operation" style="right:90px;bottom:40px;display:;" data-v-5775ee02><i class="kbnfont kbn-ban-home ban-home" data-v-5775ee02></i> <i class="kbnfont kbn-ban-message message" data-v-5775ee02></i> <i class="kbnfont kbn-ban-close close" data-v-5775ee02></i> <a target="_blank" href="https://vuepress-theme-reco.recoluan.com/views/plugins/kanbanniang.html" data-v-5775ee02><i class="kbnfont kbn-ban-info info" data-v-5775ee02></i></a> <i class="kbnfont kbn-ban-theme skin" style="display:none;" data-v-5775ee02></i></div> <canvas id="banniang" width="150" height="220" class="live2d" style="right:90px;bottom:-20px;opacity:0.9;" data-v-5775ee02></canvas></div> <div class="showBanNiang" style="display:none;" data-v-5775ee02>
    看板娘
  </div></div><div class="reco-bgm-panel" data-v-39f9e6e0><audio id="bgm" src="http://music.xf1433.com/up/view.php/bdd54db28be7bc21993e763af31e2ad0.mp3" data-v-39f9e6e0></audio> <div class="reco-float-box" style="bottom:200px;z-index:999999;display:none;" data-v-39f9e6e0 data-v-41bcba48 data-v-39f9e6e0><img src="https://gitee.com/master0037/publicImg/raw/master/1.jpg" data-v-39f9e6e0></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-39f9e6e0 data-v-41bcba48 data-v-39f9e6e0><div class="reco-bgm-cover" style="background-image:url(https://gitee.com/master0037/publicImg/raw/master/1.jpg);" data-v-39f9e6e0><div class="mini-operation" style="display:none;" data-v-39f9e6e0><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-39f9e6e0></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-39f9e6e0></i></div> <div class="falut-message" style="display:none;" data-v-39f9e6e0>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-39f9e6e0 data-v-41bcba48 data-v-39f9e6e0><div class="info-box" data-v-39f9e6e0><i class="reco-bgm reco-bgm-music music" data-v-39f9e6e0></i>夜撫でるメノウ</div> <div class="info-box" data-v-39f9e6e0><i class="reco-bgm reco-bgm-artist" data-v-39f9e6e0></i>夜撫でるメノウ</div> <div class="reco-bgm-progress" data-v-39f9e6e0><div class="progress-bar" data-v-39f9e6e0><div class="bar" data-v-39f9e6e0></div></div></div> <div class="reco-bgm-operation" data-v-39f9e6e0><i class="reco-bgm reco-bgm-last last" data-v-39f9e6e0></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-39f9e6e0></i> <i class="reco-bgm reco-bgm-play play" data-v-39f9e6e0></i> <i class="reco-bgm reco-bgm-next next" data-v-39f9e6e0></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-39f9e6e0></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-39f9e6e0></i> <div class="volume-bar" data-v-39f9e6e0><div class="bar" data-v-39f9e6e0></div></div></div></div> <div class="reco-bgm-left-box" data-v-39f9e6e0 data-v-41bcba48 data-v-39f9e6e0><i class="reco-bgm reco-bgm-left" data-v-39f9e6e0></i></div></div></div><canvas id="vuepress-canvas-ribbon"></canvas><canvas id="vuepress-canvas-cursor"></canvas><!----></div></div>
    <script src="/assets/js/app.471be3c8.js" defer></script><script src="/assets/js/3.ee027652.js" defer></script><script src="/assets/js/1.58bb6475.js" defer></script><script src="/assets/js/25.8741c09a.js" defer></script><script src="/assets/js/8.7e2c6b0f.js" defer></script>
  </body>
</html>
